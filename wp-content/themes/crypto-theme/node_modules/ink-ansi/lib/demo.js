"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const chalk = require("chalk");
const React = require("react");
const ink_1 = require("ink");
const _1 = __importDefault(require("."));
const withChalk = process.argv.includes('--chalk');
const withEmoji = process.argv.includes('--emoji');
const withControlSequences = process.argv.includes('--ctrl');
const withNesting = process.argv.includes('--nest');
const withStandardText = process.argv.includes('--standard');
const names = [
    'James',
    'John',
    'Robert',
    'Michael',
    'William',
    'David',
    'Richard',
    'Charles',
    'Joseph',
    'Thomas',
    'Christopher',
    'Daniel',
    'Paul',
    'Mark',
    'Donald',
    'George',
    'Kenneth',
    'Steven',
    'Edward',
    'Brian',
    'Ronald',
    'Anthony',
    'Kevin',
    'Jason',
    'Matthew',
    'Gary',
    'Timothy',
    'Jose',
    'Larry',
    'Jeffrey',
    'Frank',
    'Scott',
    'Eric',
    'Stephen',
    'Andrew',
    'Raymond',
    'Gregory',
    'Joshua',
    'Mary',
    'Patricia',
    'Linda',
    'Barbara',
    'Elizabeth',
    'Jennifer',
    'Maria',
    'Susan',
    'Margaret',
    'Dorothy',
    'Lisa',
    'Nancy',
    'Karen',
    'Betty',
    'Helen',
    'Sandra',
    'Donna',
    'Carol',
    'Ruth',
    'Sharon',
    'Michelle',
    'Laura',
    'Sarah',
    'Kimberly',
    'Deborah',
    'Jessica',
    'Shirley',
    'Cynthia',
    'Angela',
    'Melissa',
    'Brenda',
    'Amy',
    'Anna',
    'Rebecca',
    'Virginia',
    'Kathleen',
    'Pamela',
    'Martha',
    'Debra',
    'Amanda',
    'Stephanie',
    'Carolyn',
    'Christine',
    'Marie',
    'Janet',
    'Catherine',
    'Frances',
    'Ann',
    'Joyce',
];
const emojis = [
    '😀',
    '😃',
    '😄',
    '😁',
    '😆',
    '😅',
    '🤣',
    '😂',
    '🍻',
    '🍺',
    '😊',
];
const ForegroundColor = [
    'black',
    'red',
    'green',
    'yellow',
    'blue',
    'magenta',
    'cyan',
    'white',
    'gray',
    'grey',
    'blackBright',
    'redBright',
    'greenBright',
    'yellowBright',
    'blueBright',
    'magentaBright',
    'cyanBright',
    'whiteBright',
];
// const BackgroundColor: readonly typeof chalk.BackgroundColor[] = [
//   'bgBlack',
//   'bgRed',
//   'bgGreen',
//   'bgYellow',
//   'bgBlue',
//   'bgMagenta',
//   'bgCyan',
//   'bgWhite',
//   'bgGray',
//   'bgGrey',
//   'bgBlackBright',
//   'bgRedBright',
//   'bgGreenBright',
//   'bgYellowBright',
//   'bgBlueBright',
//   'bgMagentaBright',
//   'bgCyanBright',
//   'bgWhiteBright',
// ];
const Modifiers = [
    'reset',
    'bold',
    'dim',
    'italic',
    'underline',
    // 'inverse',
    'hidden',
    'strikethrough',
];
const controlSequences = [
    '\u001b[36m',
    '\u001b[2K',
    '\u001b[1G',
];
function randomEntry(entries) {
    const index = crypto_1.randomInt(0, entries.length);
    return entries[index];
}
function randomOrder(entries) {
    return entries
        .map((e) => [e, Math.random()])
        .sort(([, a], [, b]) => a - b)
        .map(([value]) => value);
}
function useRandomLines() {
    const [lines, setLines] = React.useState([]);
    React.useEffect(() => {
        let timeout;
        function addLine() {
            const length = 15; // randomInt(2, 30);
            const line = [];
            for (let i = 0; i < length; i++) {
                let text = randomEntry([
                    ...names,
                    ...(withEmoji ? emojis : []),
                    ...(withControlSequences
                        ? [...controlSequences, ...controlSequences, ...controlSequences]
                        : []),
                ]);
                if (withChalk) {
                    for (const key of randomOrder([
                        randomEntry([randomEntry(ForegroundColor)]),
                        // randomEntry([randomEntry(BackgroundColor)]),
                        randomEntry([randomEntry(Modifiers)]),
                    ])) {
                        if (key) {
                            text = chalk[key](text);
                        }
                    }
                }
                line.push(text);
            }
            setLines((lines) => [
                ...lines,
                line.join(randomEntry([' ', ' ', randomEntry(['\t', '\r\n', '\n', '\r '])])),
            ].slice(-5));
        }
        function run() {
            timeout = setTimeout(() => {
                addLine();
                run();
            }, crypto_1.randomInt(500, 1000));
        }
        for (let i = 0; i < 5; i++) {
            addLine();
        }
        run();
        return () => clearTimeout(timeout);
    }, []);
    return lines;
}
function FakeTerminalOutput() {
    const lines = useRandomLines();
    return (React.createElement(React.Fragment, null, lines.map((line, i) => withStandardText ? (withNesting ? (React.createElement(ink_1.Text, { key: i },
        React.createElement(ink_1.Text, { color: "greenBright" }, "["),
        React.createElement(ink_1.Text, null, line),
        React.createElement(ink_1.Text, { color: "greenBright" }, "]"))) : (React.createElement(ink_1.Text, { key: i }, line))) : withNesting ? (React.createElement(_1.default, { key: i },
        React.createElement(_1.default, { color: "greenBright" }, "["),
        React.createElement(ink_1.Text, null, line),
        React.createElement(_1.default, { color: "greenBright" }, "]"))) : (React.createElement(_1.default, { key: i }, line)))));
}
function Demo() {
    return (React.createElement(ink_1.Box, { flexDirection: "column" },
        React.createElement(ink_1.Box, { flexDirection: "row", marginX: 1, marginBottom: 1 },
            React.createElement(ink_1.Box, { flexDirection: "column", flexBasis: 0, flexGrow: 1, marginRight: 1, borderStyle: "single" },
                React.createElement(FakeTerminalOutput, null)),
            React.createElement(ink_1.Box, { flexDirection: "column", flexBasis: 0, flexGrow: 1, marginRight: 1, borderStyle: "single" },
                React.createElement(FakeTerminalOutput, null)),
            React.createElement(ink_1.Box, { flexDirection: "column", flexBasis: 0, flexGrow: 1, borderStyle: "single" },
                React.createElement(FakeTerminalOutput, null))),
        React.createElement(ink_1.Box, { flexDirection: "row", marginX: 1, marginBottom: 1 },
            React.createElement(ink_1.Box, { flexDirection: "column", flexBasis: 0, flexGrow: 1, marginRight: 1, borderStyle: "single" },
                React.createElement(FakeTerminalOutput, null)),
            React.createElement(ink_1.Box, { flexDirection: "column", flexBasis: 0, flexGrow: 1, borderStyle: "single" },
                React.createElement(FakeTerminalOutput, null))),
        React.createElement(ink_1.Box, { flexDirection: "column", marginX: 1, marginBottom: 1, borderStyle: "single" },
            React.createElement(FakeTerminalOutput, null))));
}
ink_1.render(React.createElement(Demo, null));
//# sourceMappingURL=demo.js.map