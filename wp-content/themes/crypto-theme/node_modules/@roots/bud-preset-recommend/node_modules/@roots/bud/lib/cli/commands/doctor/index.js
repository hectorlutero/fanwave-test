import { jsx as _jsx, jsxs as _jsxs } from "@roots/bud-support/jsx-runtime";
import { platform } from 'node:os';
import BudCommand from '@roots/bud/cli/commands';
import { Error } from '@roots/bud-dashboard/components/error';
import { Command } from '@roots/bud-support/clipanion';
import { BudError, InputError } from '@roots/bud-support/errors';
import figures from '@roots/bud-support/figures';
import { Box, Text } from '@roots/bud-support/ink';
import webpack from '@roots/bud-support/webpack';
import { WinError } from './WinError.js';
/**
 * bud doctor command
 */
export default class DoctorCommand extends BudCommand {
    static paths = [[`doctor`]];
    static usage = Command.Usage({
        category: `debug`,
        description: `Check project for common errors`,
        details: `\
The \`bud doctor\` command will:

1. validate the \`production\` configuration with \`webpack\`

\`webpack\` exports a \`validate\` function which is used by this command to verify that
the configuration matches the \`webpack\` configuration schema.

2. check the \`dependencies\` and \`devDependencies\` in the \`package.json\` file.

In general, \`bud.js\` dependencies should be kept at the same version. This script doesn't account
for a lot of edge cases so it might return a false positive.
`,
        examples: [
            [`Check project for common configuration issues`, `$0 doctor`],
        ],
    });
    configuration;
    disabledExtensions = [];
    enabledExtensions = [];
    entrypoints = [];
    makeTimer = () => {
        const start = process.hrtime();
        return () => {
            const end = process.hrtime(start);
            return this.seconds(end);
        };
    };
    resolvedDependencies = {};
    silent = true;
    timings = {};
    /**
     * Execute command
     */
    async execute() {
        const { Doctor } = await import(`./Doctor.js`);
        const buildTimer = this.makeTimer();
        await this.makeBud();
        await this.bud.run();
        this.timings.build = buildTimer();
        if (platform() === `win32`) {
            DoctorCommand.renderStatic(_jsx(WinError, {}));
        }
        const name = this.bud.context.manifest.name
            ? this.bud.context.manifest.name
            : this.bud.path();
        DoctorCommand.renderStatic(_jsx(Doctor, { name: name, timings: this.timings }));
        if (this.bud.hasChildren) {
            DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsxs(Text, { color: "blue", children: ["Child compilers", `\n`] }), Object.values(this.bud.children).map((child, i) => (_jsxs(Box, { flexDirection: "row", children: [_jsx(Text, { children: figures.triangleRightSmall }), _jsx(Text, { children: ` ` }), _jsx(Text, { children: child.label })] }, i))), _jsx(Text, { children: ` ` }), _jsx(Text, { children: "Note that not all `bud doctor` checks are not currently compatible with multi-compiler builds." })] }));
        }
        DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsx(Text, { color: "blue", children: "Project paths" }), _jsx(Text, { children: ` ` }), _jsxs(Text, { children: ["project: ", this.bud.path()] }), _jsxs(Text, { children: ["input:", ` `, this.bud.path(`@src`).replace(this.bud.path(), `@project`)] }), _jsxs(Text, { children: ["output:", ` `, this.bud.path(`@dist`).replace(this.bud.path(), `@project`)] }), _jsxs(Text, { children: ["cache:", ` `, this.bud.path(`@os-cache`)] }), _jsxs(Text, { children: ["storage:", ` `, this.bud.path(`@storage`).replace(this.bud.path(), `@project`)] })] }));
        DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsx(Text, { color: "blue", children: "Checking versions of core packages" }), _jsx(Text, { children: ` ` }), await this.packageCheck(`@roots/bud-api`), await this.packageCheck(`@roots/bud-build`), await this.packageCheck(`@roots/bud-cache`), await this.packageCheck(`@roots/bud-dashboard`), await this.packageCheck(`@roots/bud-extensions`), await this.packageCheck(`@roots/bud-framework`), await this.packageCheck(`@roots/bud-hooks`), await this.packageCheck(`@roots/bud-server`), await this.packageCheck(`@roots/bud-support`)] }));
        DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsx(Text, { color: "blue", children: "Mode" }), _jsx(Text, { children: this.bud.mode })] }));
        const configs = Object.values(this.bud.context.files).filter(({ bud }) => bud);
        if (configs.length) {
            DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsxs(Text, { color: "blue", children: ["Bud configuration files", `\n`] }), configs.map(({ name, path }, i) => (_jsxs(Box, { children: [_jsxs(Text, { children: [figures.triangleRightSmall, " ", name] }), _jsx(Text, { children: ` ` }), _jsx(Text, { dimColor: true, children: path.replace(this.bud.context.basedir, `.`) })] }, i)))] }));
        }
        else {
            DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsxs(Text, { color: "blue", children: ["Registered configurations", `\n`] }), _jsx(Text, { dimColor: true, children: "No configuration files found in project" })] }));
        }
        try {
            this.configuration = await this.bud.build.make();
            this.entrypoints = this.configuration.entry
                ? Object.entries(this.configuration.entry)
                : [];
            await Promise.all(Object.entries(this.bud.extensions.repository).map(async ([name, extension]) => {
                if (extension.isEnabled()) {
                    return this.enabledExtensions.push([name, extension]);
                }
                return this.disabledExtensions.push([name, extension]);
            }));
        }
        catch (error) {
            DoctorCommand.renderStatic(_jsx(Error, { error: BudError.normalize(error) }));
        }
        if (this.bud.env) {
            try {
                DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsxs(Text, { color: "blue", children: ["Environment", `\n`] }), this.bud.env.getEntries().map(([key, value]) => {
                            const color = value.length === 0 ? `yellow` : `dimColor`;
                            return (_jsxs(Box, { flexDirection: "row", children: [_jsx(Text, { children: figures.triangleRightSmall }), _jsx(Text, { children: ` ` }), _jsx(Text, { color: color, children: key }), _jsx(Text, { children: ` ` }), _jsx(Text, { color: color, children: value.length > 0 ? `************` : `empty string` })] }, key));
                        })] }));
            }
            catch (error) {
                DoctorCommand.renderStatic(_jsx(Error, { error: BudError.normalize(error) }));
            }
        }
        if (this.enabledExtensions) {
            try {
                DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsxs(Text, { color: "blue", children: ["Enabled extensions", `\n`] }), this.mapExtensions(this.enabledExtensions)] }));
                DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsxs(Text, { color: "blue", children: ["Disabled extensions", `\n`] }), this.mapExtensions(this.disabledExtensions)] }));
            }
            catch (error) {
                DoctorCommand.renderStatic(_jsx(Error, { error: BudError.normalize(error) }));
            }
        }
        if (!this.bud.hasChildren &&
            this.entrypoints.length === 1 &&
            this.entrypoints[0][0] === `main` &&
            this.entrypoints[0][1].import[0] === `index` &&
            !(await this.bud.fs.exists(this.bud.path(`@src/index.js`)))) {
            DoctorCommand.renderStatic(_jsx(Error, { error: new InputError(`No entrypoint specified`, {
                    details: `No entrypoint was specified and there is also no file resolvable at \`${this.bud.relPath(`@src/index.js`)}\`. Either specify an entrypoint or create a file at \`${this.bud.relPath(`@src/index.js`)}\`.`,
                }) }));
        }
        if (this.bud.mode === `development`) {
            DoctorCommand.renderStatic(_jsxs(Box, { flexDirection: "column", children: [_jsx(Text, { color: "blue", children: "Development server" }), _jsxs(Box, { flexDirection: "row", children: [_jsx(Text, { children: "URL:" }), _jsxs(Text, { children: [` `, this.bud.server.url.href] })] }), this.bud.server?.enabledMiddleware && Object.keys(this.bud.server.enabledMiddleware).includes(`proxy`) && this.bud.server.proxyUrl && (_jsxs(Box, { flexDirection: "row", children: [_jsx(Text, { children: "Proxy:" }), _jsxs(Text, { children: [` `, this.bud.server.proxyUrl.href] })] }))] }));
        }
        try {
            webpack.validate(this.configuration);
            DoctorCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: [figures.tick, " webpack validated configuration"] }) }));
        }
        catch (error) {
            DoctorCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "red", children: ["\u274C ", error?.message ?? error] }) }));
        }
    }
    mapExtensions(extensions) {
        return extensions.map(([name, extension]) => (_jsx(Box, { flexDirection: "column", children: _jsxs(Text, { color: "white", children: [figures.triangleRightSmall, " ", name] }) }, `extension-${name}`)));
    }
    async packageCheck(signifier) {
        const manifest = await this.bud.module.getManifestPath(signifier);
        const { version: packageVersion } = await this.bud.fs.read(manifest);
        if (packageVersion !== this.bud.context.bud.version) {
            return (_jsx(Error, { error: BudError.normalize(`${signifier} is not installed at the same version as @roots/bud (required: ${this.bud.context.bud.version}, installed: ${packageVersion}).
          Your installation may be corrupted or your package manager may have cached an outdated module; consider reinstalling with the \`--force\` flag.`) }));
        }
        else {
            return (_jsxs(Text, { children: [_jsxs(Text, { color: "green", children: [figures.tick, " ", signifier, " meets requirements"] }), ` `, "(required:", ` `, this.bud.context.bud.version, ", installed: ", packageVersion, ")"] }));
        }
    }
    seconds(hrTime) {
        return (hrTime[0] + hrTime[1] / 1e9).toFixed(2);
    }
}
