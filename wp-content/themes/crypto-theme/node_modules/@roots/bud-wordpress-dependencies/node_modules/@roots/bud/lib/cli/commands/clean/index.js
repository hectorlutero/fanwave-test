import { __decorate } from "tslib";
import { jsxs as _jsxs, jsx as _jsx } from "@roots/bud-support/jsx-runtime";
import BudCommand from '@roots/bud/cli/commands';
import { Command, Option } from '@roots/bud-support/clipanion';
import { bind } from '@roots/bud-support/decorators/bind';
import { Box, Text } from '@roots/bud-support/ink';
/**
 * `bud clean`
 */
export default class BudCleanCommand extends BudCommand {
    static paths = [[`clean`]];
    static usage = Command.Usage({
        category: `task`,
        description: `Clean project artifacts and caches`,
        details: `
      \`bud clean\` empties the \`@dist\` and \`@storage\` directories.
      \`bud clean @dist\` empties the \`@dist\` directory.
      \`bud clean @storage\` empties the \`@storage\` directory.
      \`bud clean cache\` empties the \`@storage/cache\` directory.
`,
        examples: [
            [`Clean all`, `$0 clean`],
            [`Clean dist`, `$0 clean output`],
            [`Clean storage`, `$0 clean storage`],
        ],
    });
    cachePositional = Option.Boolean(`@cache,cache`, false, {
        description: `empty @cache`,
    });
    outputPositional = Option.Boolean(`@dist,dist,output`, false, {
        description: `empty @dist`,
    });
    storagePositional = Option.Boolean(`@storage,storage`, false, {
        description: `empty @storage`,
    });
    async catch(error) { }
    async cleanCache() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.cache.cacheDirectory);
                BudCleanCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", child.cache.cacheDirectory] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@os-cache`));
        BudCleanCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", this.bud.cache.cacheDirectory] }) }));
        await this.bud.fs.remove(this.bud.path(`@storage`, `conf`));
        BudCleanCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@storage`, `conf`)] }) }));
    }
    async cleanOutput() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.path(`@dist`));
                BudCleanCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", child.path(`@dist`)] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@dist`));
        BudCleanCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@dist`)] }) }));
    }
    async cleanStorage() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.path(`@storage`));
                BudCleanCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", child.path(`@storage`)] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@storage`));
        await this.bud.fs.remove(this.bud.path(`@os-cache`));
        BudCleanCommand.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@storage`)] }) }));
    }
    /**
     * {@link Command.execute}
     */
    async execute() {
        await this.makeBud();
        const cleanAll = !this.outputPositional &&
            !this.storagePositional &&
            !this.cachePositional;
        if (this.storagePositional || cleanAll) {
            await this.cleanStorage();
        }
        if (this.outputPositional || cleanAll) {
            await this.cleanOutput();
        }
        if (this.cachePositional || cleanAll) {
            await this.cleanCache();
        }
    }
    filterCompiler(child) {
        return !this.filter || this.filter.includes(child.label);
    }
}
__decorate([
    bind
], BudCleanCommand.prototype, "catch", null);
__decorate([
    bind
], BudCleanCommand.prototype, "cleanCache", null);
__decorate([
    bind
], BudCleanCommand.prototype, "cleanOutput", null);
__decorate([
    bind
], BudCleanCommand.prototype, "cleanStorage", null);
__decorate([
    bind
], BudCleanCommand.prototype, "filterCompiler", null);
