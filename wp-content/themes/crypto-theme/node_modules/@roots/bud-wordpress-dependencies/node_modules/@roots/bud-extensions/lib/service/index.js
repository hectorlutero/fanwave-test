import { __decorate } from "tslib";
import { randomUUID } from 'node:crypto';
import { handleManifestSchemaWarning } from '@roots/bud-extensions/helpers/handleManifestSchemaWarning';
import { isConstructor } from '@roots/bud-extensions/helpers/isConstructor';
import { Extension } from '@roots/bud-framework/extension';
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators/bind';
import { ExtensionError } from '@roots/bud-support/errors';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import Container from '@roots/container';
/**
 * Extensions Service
 */
class Extensions extends Service {
    /**
     * {@link Service.label}
     */
    label = `extensions`;
    /**
     * Resolved options
     */
    options;
    /**
     * Registered extensions
     */
    repository;
    /**
     * Modules on which an import attempt was made and failed
     *
     * @remarks
     * This doesn't mean an error, per se. This should only
     * be used in the context of trying to import `optionalDependencies`
     * of a given extension module.
     *
     * @public
     */
    unresolvable;
    /**
     *
     * @param bud Class constructor
     */
    constructor(bud) {
        super(bud);
        this.options = new Container({
            allowlist: [],
            denylist: [],
            discover: true,
        });
        this.repository = {};
        this.unresolvable = new Set();
    }
    /**
     * Add a {@link Extension} to the extensions repository
     */
    async add(extension) {
        const arrayed = Array.isArray(extension) ? extension : [extension];
        await arrayed.reduce(async (promised, item) => {
            await promised;
            const moduleObject = typeof item === `string`
                ? await import(item).then(pkg => pkg.default ?? pkg)
                : item;
            const extension = await this.instantiate(moduleObject);
            this.set(extension);
            await this.run(extension, `register`);
            await this.run(extension, `boot`);
        }, Promise.resolve());
    }
    /**
     * {@link BudExtensions.boot}
     */
    async boot(bud) {
        await this.runAll(`boot`);
    }
    /**
     * {@link BudExtensions.bootstrap}
     */
    async bootstrap(bud) {
        handleManifestSchemaWarning.bind(this)(bud);
        const { extensions, manifest } = bud.context;
        if (manifest?.bud?.extensions) {
            const { allowlist, denylist } = manifest.bud.extensions;
            const discover = manifest.bud.extensions.discover ??
                manifest.bud.extensions.discovery;
            if (!isUndefined(discover))
                this.options.set(`discover`, discover);
            if (!isUndefined(allowlist))
                this.options.merge(`allowlist`, allowlist);
            if (!isUndefined(denylist))
                this.options.merge(`denylist`, denylist);
        }
        if (manifest?.bud?.[this.app.label]?.extensions) {
            const { allowlist, denylist } = manifest.bud[this.app.label].extensions;
            const discover = manifest.bud[this.app.label].extensions.discover ??
                manifest.bud[this.app.label].extensions.discovery;
            if (!isUndefined(discover))
                this.options.set(`discover`, discover);
            if (!isUndefined(allowlist))
                this.options.set(`allowlist`, (allowed = []) => [
                    ...allowed,
                    ...allowlist,
                ]);
            if (!isUndefined(denylist))
                this.options.set(`denylist`, (denied = []) => [
                    ...denied,
                    ...allowlist,
                ]);
        }
        if (!isUndefined(extensions?.builtIn) &&
            Array.isArray(extensions.builtIn))
            await Promise.all(extensions.builtIn
                .filter(Boolean)
                .map(async (signifier) => await this.import(signifier, true)));
        if (!isUndefined(bud.context.discover)) {
            this.options.set(`discover`, bud.context.discover);
        }
        if (this.options.is(`discover`, true) &&
            this.options.isEmpty(`allowlist`) &&
            !isUndefined(extensions?.discovered) &&
            Array.isArray(extensions.discovered))
            await Promise.all(extensions.discovered
                .filter(Boolean)
                .filter(this.isAllowed)
                .map(async (signifier) => await this.import(signifier, true)));
        else if (this.options.isNotEmpty(`allowlist`))
            await Promise.all(this.options
                .get(`allowlist`)
                .filter(Boolean)
                .filter(this.isAllowed)
                .map(async (signifier) => await this.import(signifier, true)));
    }
    /**
     * {@link BudExtensions.buildBefore}
     */
    async buildAfter(bud) {
        await this.runAll(`buildAfter`);
    }
    /**
     * {@link BudExtensions.buildBefore}
     */
    async buildBefore(bud) {
        await this.runAll(`buildBefore`);
    }
    /**
     * {@link BudExtensions.compilerDone}
     */
    async compilerDone(bud, stats) {
        await this.runAll(`compilerDone`);
    }
    /**
     * {@link BudExtensions.configAfter}
     */
    async configAfter(bud) {
        await this.runAll(`configAfter`);
    }
    /**
     * Get extension
     */
    get(key) {
        return this.repository[key];
    }
    /**
     * Has extension
     */
    has(key) {
        return this.repository[key] ? true : false;
    }
    /**
     * Import an extension
     */
    async import(signifier, required = true) {
        if (required && this.unresolvable.has(signifier))
            throw new Error(`Extension ${signifier} is not importable`);
        if (signifier.startsWith(`.`)) {
            signifier = this.app.path(signifier);
            this.logger.info(`path resolved to`, signifier);
        }
        if (this.has(signifier)) {
            this.logger.info(signifier, `already imported`);
            return this.get(signifier);
        }
        const extension = await this.app.module
            .import(signifier, import.meta.url)
            .catch(error => {
            this.unresolvable.add(signifier);
            if (required)
                throw error;
        });
        if (!extension) {
            if (required)
                throw new ExtensionError(`Extension ${signifier} not found but required`);
            return;
        }
        const instance = await this.instantiate(extension);
        if (instance.dependsOn)
            await Promise.all(Array.from(instance.dependsOn)
                .filter(dependency => !this.has(dependency))
                .map(async (dependency) => await this.import(dependency, true)));
        if (this.options.is(`discover`, true) && instance.dependsOnOptional)
            await Promise.all(Array.from(instance.dependsOnOptional)
                .filter(this.isAllowed)
                .filter(optionalDependency => !this.unresolvable.has(optionalDependency))
                .filter(optionalDependency => !this.has(optionalDependency))
                .map(async (optionalDependency) => {
                await this.import(optionalDependency, false);
                if (!this.has(optionalDependency))
                    this.unresolvable.add(optionalDependency);
            }));
        this.set(instance);
        return instance;
    }
    /**
     * {@link BudExtensions.instantiate}
     */
    async instantiate(source) {
        if (source instanceof Extension)
            return source;
        if (isConstructor(source)) {
            return new source(this.app);
        }
        if (typeof source === `function`) {
            return source(this.app);
        }
        if (typeof source.apply === `function`) {
            return source;
        }
        if (!isConstructor(source)) {
            const instance = new Extension(this.app);
            Object.entries(source).forEach(([k, v]) => {
                if (k === `options`) {
                    instance.setOptions(v);
                    return;
                }
                instance[k] = v;
            });
            return instance;
        }
        return new source();
    }
    /**
     * {@link BudExtensions.isAllowed}
     */
    isAllowed(signifier) {
        return ((this.options.isEmpty(`denylist`) ||
            !this.options.get(`denylist`).includes(signifier)) &&
            (this.options.isEmpty(`allowlist`) ||
                this.options.get(`allowlist`).includes(signifier)));
    }
    /**
     * Returns an array of plugin instances which have been registered to the
     * container and are set to be used in the compilation
     *
     * @returns An array of plugin instances
     */
    async make() {
        return await Promise.all(Object.values(this.repository).map(async (extension) => extension.apply ? extension : await extension._make())).then((result) => result.filter(Boolean));
    }
    /**
     * {@link BudExtensions.register}
     */
    async register(bud) {
        await this.runAll(`register`);
    }
    /**
     * Remove extension
     */
    remove(key) {
        delete this.repository[key];
        return this;
    }
    /**
     * Run an extension lifecycle method
     *
     * @remarks
     * - `_register`
     * - `_boot`
     * - `_buildBefore`
     * - `_make`
     */
    async run(extension, methodName) {
        try {
            await this.runDependencies(extension, methodName);
            const method = extension[`_${methodName}`];
            if (isFunction(method))
                await method();
            await this.app.promise();
            return this;
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Execute a extension lifecycle method on all registered extensions
     */
    async runAll(methodName) {
        return await Object.values(this.repository).reduce(async (promised, extension) => {
            await promised;
            await this.run(extension, methodName);
        }, Promise.resolve());
    }
    /**
     * Run a lifecycle method for an extension's dependencies
     *
     * @remarks
     * Called from {@link Extension.run}. Ensures a method is run for an
     * extension's dependencies before it is run for the extension itself.
     */
    async runDependencies(extension, methodName) {
        const instance = typeof extension === `string` ? this.get(extension) : extension;
        if (instance.dependsOn) {
            await Array.from(instance.dependsOn)
                .filter(this.isAllowed)
                .filter((signifier) => !this.unresolvable.has(signifier))
                .reduce(async (promised, signifier) => {
                await promised;
                if (!this.has(signifier))
                    await this.import(signifier, true);
                if (this.get(signifier) &&
                    !this.get(signifier).meta?.[methodName])
                    await this.run(this.get(signifier), methodName);
            }, Promise.resolve());
        }
        if (this.options.is(`discover`, true) && instance.dependsOnOptional)
            await Array.from(instance.dependsOnOptional)
                .filter(this.isAllowed)
                .filter((signifier) => !this.unresolvable.has(signifier))
                .reduce(async (promised, signifier) => {
                await promised;
                if (!this.has(signifier))
                    await this.import(signifier, false);
                if (!this.has(signifier)) {
                    this.unresolvable.add(signifier);
                    return;
                }
                if (this.get(signifier) &&
                    !this.get(signifier).meta?.[methodName])
                    await this.run(this.get(signifier), methodName);
            }, Promise.resolve());
    }
    /**
     * Set extension
     */
    set(value) {
        const key = (value.label ?? randomUUID());
        this.repository[key] = value;
        this.logger.success(`set`, key);
        return this;
    }
}
__decorate([
    bind
], Extensions.prototype, "add", null);
__decorate([
    bind
], Extensions.prototype, "get", null);
__decorate([
    bind
], Extensions.prototype, "has", null);
__decorate([
    bind
], Extensions.prototype, "import", null);
__decorate([
    bind
], Extensions.prototype, "instantiate", null);
__decorate([
    bind
], Extensions.prototype, "isAllowed", null);
__decorate([
    bind
], Extensions.prototype, "make", null);
__decorate([
    bind
], Extensions.prototype, "remove", null);
__decorate([
    bind
], Extensions.prototype, "run", null);
__decorate([
    bind
], Extensions.prototype, "runAll", null);
__decorate([
    bind
], Extensions.prototype, "runDependencies", null);
__decorate([
    bind
], Extensions.prototype, "set", null);
export { Extensions as default };
