import type { Bud } from '@roots/bud-framework';
import type { Modules } from '@roots/bud-framework';
import type { Compiler } from '@roots/bud-framework/config';
import type { ApplyPluginConstructor } from '@roots/bud-framework/extension/decorators/plugin';
import logger from '@roots/bud-support/logger';
import DynamicOption from '@roots/bud-support/value';
export type Options<T = Record<string, any>> = {
    [K in keyof T as `${K & string}`]?: T[K];
};
export type InternalOptionsValues<T extends Options> = {
    [K in keyof T as `${K & string}`]: DynamicOption<(app: Bud) => T[K]> | T[K];
};
export type OptionCallback<T extends Options, K extends `${keyof Options & string}`> = ((value: T[K]) => T[K]) | T[K];
export type OptionCallbackValue<T extends Options, K extends `${keyof Options & string}`> = ((value: T[K]) => T[K]) | InternalOptionsValues<T>[K];
export type OptionSetter<Extension, Options, Property extends `${keyof Options & string}`> = (value: OptionCallbackValue<Options, Property>) => Extension;
export type OptionGetter<Options extends Record<string, any>, Property extends `${keyof Options & string}`> = () => Options[Property];
export type OptionAccessor<Options extends Record<string, any>, Property extends `${keyof Options & string}`> = Options[Property];
export type Option<Extension, Options extends Record<string, any>, Property extends `${keyof Options & string}`> = {
    get: OptionGetter<Options, Property>;
    set: OptionSetter<Extension, Options, Property>;
    value: OptionAccessor<Options, Property>;
};
export interface Meta {
    boot: boolean;
    buildAfter: boolean;
    buildBefore: boolean;
    configAfter: boolean;
    register: boolean;
}
/**
 * Webpack plugin.
 */
export interface ApplyPlugin {
    /**
     * @see {@link https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture}
     */
    apply?(...args: any[]): unknown;
}
export interface Constructor {
    new (...args: any[]): Extension;
}
export type WithOptions<Context, Options> = {
    [Prop in keyof Options as `get${Capitalize<Prop & string>}`]: () => Options[Prop];
} & {
    [Prop in keyof Options as `set${Capitalize<Prop & string>}`]: (value: OptionCallbackValue<Options, `${Prop & string}`>) => Context;
} & {
    [K in keyof Options as `${K & string}`]: Options[K];
};
export type StrictPublicExtensionApi<Context, Opts extends Options> = {
    app: Bud;
    enable: (boolean?: boolean) => Context;
    enabled: boolean;
    get: <K extends `${keyof Opts & string}`>(key: K) => Opts[K];
    getOptions: () => Opts;
    logger: typeof logger;
    options: Opts;
    set: <K extends `${keyof Opts & string}`>(key: K, value: ((value: Opts[K]) => Opts[K]) | Opts[K]) => Context;
    setOptions: (O: Partial<InternalOptionsValues<Opts>>) => Context;
} & WithOptions<Context, Opts>;
export type PublicExtensionApi<E extends Extension = Extension> = {
    app: E[`app`];
    enable: E['enable'];
    enabled: E['enabled'];
    get: E[`getOption`];
    getOption: E[`getOption`];
    getOptions: E[`getOptions`];
    options: E['options'];
    set: E[`set`];
    setOption: E[`setOption`];
    setOptions: E[`setOptions`];
};
export type ExtensionLiteral = Partial<Extension>;
export type * as Logger from '@roots/bud-support/logger';
/**
 * Bud extension
 */
export declare class Extension<ExtensionOptions extends Options = Options, Plugin extends ApplyPlugin = ApplyPlugin> {
    /**
     * Application
     */
    _app: () => Bud;
    /**
     * Extension options
     */
    _options: Partial<InternalOptionsValues<ExtensionOptions>>;
    /**
     * Depends on
     */
    dependsOn?: Set<keyof Modules & string>;
    /**
     * Depends on (optional)
     */
    dependsOnOptional?: Set<`${keyof Modules & string}`>;
    /**
     * Is extension enabled
     *
     * @remarks
     * The following methods are skipped if `enabled` is false:
     * - {@link Extension.buildBefore}
     * - {@link Extension.make}
     */
    enabled: boolean;
    get: <K extends string>(key: K) => ExtensionOptions[K];
    /**
     * The module name
     */
    label: `${keyof Modules & string}`;
    /**
     * Extension meta
     */
    meta: Meta;
    /**
     * Extension options
     *
     * @readonly
     */
    options: ExtensionOptions;
    /**
     * Plugin constructor
     */
    plugin?: ApplyPluginConstructor;
    set: <K extends string>(key: K, valueOrCallback: OptionCallbackValue<ExtensionOptions, K>) => this;
    /**
     * Class constructor
     */
    constructor(app: Bud);
    /**
     * Application accessor
     */
    get app(): Bud;
    /**
     * {@link ApplyPlugin.apply}
     */
    apply?(compiler: Compiler): unknown | void;
    /**
     * `boot` callback
     */
    boot?(app: Bud): Promise<unknown | void>;
    /**
     * `buildAfter` callback
     */
    buildAfter?(app: Bud): Promise<unknown | void>;
    /**
     * `buildBefore` callback
     */
    buildBefore?(app: Bud): Promise<unknown | void>;
    catch(error: Error | string): never;
    /**
     * `configAfter` callback
     */
    configAfter?(app: Bud): Promise<unknown | void>;
    /**
     * Disable extension
     * @deprecated pass `false` to {@link Extension.enable}
     */
    disable(): void;
    /**
     * Return to bud instance from extension
     */
    done(): Bud;
    /**
     * Enable extension
     */
    enable(enabled?: boolean): this;
    /**
     * Get extension option
     */
    getOption<K extends string>(key: K): ExtensionOptions[K];
    getOptions(): ExtensionOptions;
    /**
     * Import ESM module
     */
    import<T = any>(signifier: string, context: string, options?: {
        bustCache?: boolean;
        raw?: boolean;
    }): Promise<T | undefined>;
    /**
     * Is extension enabled?
     */
    isEnabled(): boolean;
    /**
     * Logger instance
     */
    get logger(): any;
    /**
     * `make` callback
     */
    make?(app: Bud, options?: ExtensionOptions): Promise<Plugin>;
    /**
     * {@link Extension.register}
     */
    register?(app: Bud): Promise<any>;
    /**
     * Resolve module using `import.meta.resolve` api
     */
    resolve(signifier: string, context: string): Promise<string>;
    /**
     * Set extension option
     */
    setOption<K extends string>(key: K, valueOrCallback: OptionCallbackValue<ExtensionOptions, K>): this;
    /**
     * Set extension options
     */
    setOptions(value: Partial<InternalOptionsValues<ExtensionOptions>>): this;
    /**
     * Function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * By default returns {@link Extension.enabled}
     */
    when(bud: Bud, options?: ExtensionOptions): boolean;
    /**
     * `boot` callback handler
     */
    _boot(): Promise<void>;
    /**
     * `buildAfter` callback handler
     */
    _buildAfter(): Promise<void>;
    /**
     * `buildBefore` callback handler
     */
    _buildBefore(): Promise<void>;
    /**
     * `configAfter` callback handler
     */
    _configAfter(): Promise<void>;
    /**
     * `make` callback handler
     */
    _make(): Promise<false | import("@roots/bud-framework/extension/decorators/plugin").ApplyPlugin | Plugin | this>;
    /**
     * `register` callback handler
     */
    _register(): Promise<void>;
}
export { DynamicOption };
