import { __decorate } from "tslib";
import { bind } from '@roots/bud-support/decorators/bind';
import { BudError, ExtensionError } from '@roots/bud-support/errors';
import get from '@roots/bud-support/lodash/get';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isObject from '@roots/bud-support/lodash/isObject';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import set from '@roots/bud-support/lodash/set';
import logger from '@roots/bud-support/logger';
import DynamicOption from '@roots/bud-support/value';
/**
 * Bud extension
 */
export class Extension {
    /**
     * Application
     */
    _app;
    /**
     * Extension options
     */
    _options;
    /**
     * Depends on
     */
    dependsOn;
    /**
     * Depends on (optional)
     */
    dependsOnOptional;
    /**
     * Is extension enabled
     *
     * @remarks
     * The following methods are skipped if `enabled` is false:
     * - {@link Extension.buildBefore}
     * - {@link Extension.make}
     */
    enabled = true;
    get = this.getOption;
    /**
     * The module name
     */
    label;
    /**
     * Extension meta
     */
    meta = {
        boot: false,
        buildAfter: false,
        buildBefore: false,
        configAfter: false,
        register: false,
    };
    /**
     * Extension options
     *
     * @readonly
     */
    options;
    /**
     * Plugin constructor
     */
    plugin;
    set = this.setOption;
    /**
     * Class constructor
     */
    constructor(app) {
        this._app = () => app;
        this._options = this.options ? { ...this.options } : {};
        delete this.options;
        Object.defineProperty(this, `options`, {
            get: this.getOptions.bind(this),
        });
    }
    /**
     * Application accessor
     */
    get app() {
        return this._app();
    }
    catch(error) {
        const thrownBy = this.label ?? this.constructor?.name ?? `unknown_extension`;
        if (error instanceof ExtensionError) {
            error.instance = this.app.label;
            error.thrownBy = error.thrownBy ?? thrownBy;
            throw error;
        }
        throw new ExtensionError(typeof error === `string` ? error : error.message, {
            docs: new URL(`https://bud.js.org/docs/extensions`),
            issue: new URL(`https://github.com/roots/bud/search?q=is:issue+${thrownBy} in:title`),
            origin: BudError.normalize(error),
            thrownBy,
        });
    }
    /**
     * Disable extension
     * @deprecated pass `false` to {@link Extension.enable}
     */
    disable() {
        this.enabled = false;
    }
    /**
     * Return to bud instance from extension
     */
    done() {
        return this.app;
    }
    /**
     * Enable extension
     */
    enable(enabled = true) {
        this.enabled = enabled;
        return this;
    }
    /**
     * Get extension option
     */
    getOption(key) {
        return get(this.options, key);
    }
    getOptions() {
        return Object.entries(this._options).reduce((acc, [key, value]) => {
            if (isUndefined(value))
                return acc;
            if (!isObject(value))
                return { ...acc, [key]: value };
            const isDynamicOption = (value) => {
                return (value instanceof DynamicOption ||
                    (`isBudValue` in value && value.isBudValue));
            };
            const unwrapped = isDynamicOption(value)
                ? value.get()(this.app)
                : value;
            if (isUndefined(unwrapped))
                return acc;
            return { ...acc, [key]: unwrapped };
        }, {});
    }
    /**
     * Import ESM module
     */
    async import(signifier, context, options = {
        bustCache: false,
        raw: false,
    }) {
        return await this.app.module
            .import(signifier, context, options)
            .catch(this.catch);
    }
    /**
     * Is extension enabled?
     */
    isEnabled() {
        return this.when(this.app, this.options);
    }
    /**
     * Logger instance
     */
    get logger() {
        return logger.scope(...[this.app.label, this.label].filter(Boolean));
    }
    /**
     * Resolve module using `import.meta.resolve` api
     */
    async resolve(signifier, context) {
        try {
            return await this.app.module.resolve(signifier, context);
        }
        catch (error) {
            this.catch(new ExtensionError(`could not resolve ${signifier}`, {
                origin: error,
                thrownBy: this.label,
            }));
        }
    }
    /**
     * Set extension option
     */
    setOption(key, valueOrCallback) {
        if (isFunction(valueOrCallback)) {
            set(this._options, key, valueOrCallback(this.get(key)));
            return this;
        }
        set(this._options, key, valueOrCallback);
        return this;
    }
    /**
     * Set extension options
     */
    setOptions(value) {
        this._options = value;
        return this;
    }
    /**
     * Function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * By default returns {@link Extension.enabled}
     */
    when(bud, options) {
        return this.enabled;
    }
    /**
     * `boot` callback handler
     */
    async _boot() {
        if (isUndefined(this.boot))
            return;
        if (this.meta[`boot`] === true)
            return;
        this.meta[`boot`] = true;
        await this.boot(this.app).catch(this.catch);
    }
    /**
     * `buildAfter` callback handler
     */
    async _buildAfter() {
        if (isUndefined(this.buildAfter))
            return;
        if (!this.isEnabled())
            return;
        if (this.meta[`buildAfter`] === true)
            return;
        this.meta[`buildAfter`] = true;
        await this.buildAfter(this.app).catch(this.catch);
    }
    /**
     * `buildBefore` callback handler
     */
    async _buildBefore() {
        if (isUndefined(this.buildBefore))
            return;
        if (!this.isEnabled())
            return;
        if (this.meta[`buildBefore`] === true)
            return;
        this.meta[`buildBefore`] = true;
        await this.buildBefore(this.app).catch(this.catch);
    }
    /**
     * `configAfter` callback handler
     */
    async _configAfter() {
        if (isUndefined(this.configAfter))
            return;
        if (this.meta[`configAfter`] === true)
            return;
        this.meta[`configAfter`] = true;
        await this.configAfter(this.app).catch(this.catch);
    }
    /**
     * `make` callback handler
     */
    async _make() {
        if (isUndefined(this.make) && isUndefined(this.plugin))
            return false;
        if (this.isEnabled() === false)
            return false;
        try {
            if (!isUndefined(this.apply)) {
                this.logger.info(`apply prop found. return extension instance`);
                return this;
            }
            if (!isUndefined(this.plugin)) {
                const plugin = new this.plugin({ ...this.options });
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
            if (!isUndefined(this.make)) {
                const plugin = await this.make(this.app, { ...this.options });
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
        }
        catch (error) {
            this.catch(error);
        }
    }
    /**
     * `register` callback handler
     */
    async _register() {
        if (isUndefined(this.register))
            return;
        if (this.meta[`register`] === true)
            return;
        this.meta[`register`] = true;
        await this.register(this.app).catch(this.catch);
    }
}
__decorate([
    bind
], Extension.prototype, "catch", null);
__decorate([
    bind
], Extension.prototype, "disable", null);
__decorate([
    bind
], Extension.prototype, "done", null);
__decorate([
    bind
], Extension.prototype, "enable", null);
__decorate([
    bind
], Extension.prototype, "getOption", null);
__decorate([
    bind
], Extension.prototype, "import", null);
__decorate([
    bind
], Extension.prototype, "isEnabled", null);
__decorate([
    bind
], Extension.prototype, "resolve", null);
__decorate([
    bind
], Extension.prototype, "setOption", null);
__decorate([
    bind
], Extension.prototype, "_boot", null);
__decorate([
    bind
], Extension.prototype, "_buildAfter", null);
__decorate([
    bind
], Extension.prototype, "_buildBefore", null);
__decorate([
    bind
], Extension.prototype, "_configAfter", null);
__decorate([
    bind
], Extension.prototype, "_make", null);
__decorate([
    bind
], Extension.prototype, "_register", null);
export { DynamicOption };
