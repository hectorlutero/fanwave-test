import { __decorate } from "tslib";
import { join, normalize, relative } from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';
import { bind } from '@roots/bud-support/decorators/bind';
import { ModuleError } from '@roots/bud-support/errors';
import { resolve } from '@roots/bud-support/import-meta-resolve';
import noop from '@roots/bud-support/lodash/noop';
import logger from '@roots/bud-support/logger';
import args from '@roots/bud-support/utilities/args';
import { paths } from '@roots/bud-support/utilities/paths';
import {} from './index.js';
import { Service } from './service.js';
/**
 * Module resolver
 */
export class Module extends Service {
    /**
     * Resolved module cache
     */
    resolved = {};
    /**
     * At end of process write resolutions to cache
     */
    async after() {
        await this.app.fs.write(this.resolutionsPath, {
            resolutions: this.resolved,
            version: this.app.context.bud.version,
        });
    }
    /**
     * {@link Service.bootstrap}
     */
    async bootstrap(bud) {
        if (args.force) {
            logger
                .scope(`module`)
                .info(`flushing resolutions`, this.resolutionsPath);
        }
        if (!this.cacheEnabled) {
            this.resolved = {};
            return;
        }
        const data = await bud.fs.read(this.resolutionsPath).catch(error => {
            logger.scope(`module`).info(`cache is enabled but no cache exists`);
            this.resolved = {};
        });
        if (!data?.resolutions) {
            logger
                .scope(`module`)
                .info(`cache is enabled but resolution data is missing`, data);
            this.resolved = {};
            return;
        }
        logger
            .scope(`module`)
            .info(`cache is enabled and cached resolutions exist`, data);
        this.resolved = data.resolutions;
    }
    /**
     * Cache enabled
     */
    get cacheEnabled() {
        if (args.force === true)
            return false;
        if (args.cache === false)
            return false;
        return true;
    }
    /**
     * {@link Service.compilerBefore}
     */
    async compilerBefore(bud) {
        await bud.fs
            .write(this.resolutionsPath, {
            resolutions: this.resolved,
            version: bud.context.bud.version,
        })
            .catch(this.catch)
            .then(result => {
            bud.fs.read(this.resolutionsPath);
        });
    }
    /**
     * Get `package.json` absolute path from a module signifier
     */
    async getDirectory(signifier, context) {
        return await this.resolve(signifier, context)
            .then(path => relative(this.app.context.basedir, path))
            .then(path => path.split(signifier).shift())
            .then(path => this.app.path(path, signifier))
            .catch(this.catch);
    }
    /**
     * Get `package.json` absolute path from a module signifier
     */
    async getManifestPath(pkgName) {
        return await this.getDirectory(pkgName)
            .then(dir => this.app.path(dir, `package.json`))
            .catch(this.catch);
    }
    /**
     * Import a module from its signifier
     */
    async import(signifier, context, options = {
        bustCache: false,
        raw: false,
    }) {
        if (this.resolved?.[signifier]) {
            const path = options.bustCache
                ? `${this.resolved[signifier]}?v=${Date.now()}`
                : this.resolved[signifier];
            const result = await import(path).catch(error => {
                logger
                    .scope(`module`)
                    .info(`Could not import ${signifier} from ${this.resolved[signifier]}. Removing from cached module registry.`, error);
                delete this.resolved[signifier];
            });
            return options.raw ? result : result?.default ?? result;
        }
        const path = await this.resolve(signifier, context).catch(this.catch);
        const result = await import(path).catch(this.catch);
        logger.scope(`module`).info(`[cache miss]`, `imported`, signifier);
        return options.raw ? result : result?.default ?? result;
    }
    /**
     * Make context URL
     */
    makeContextURL(context) {
        return (context ??
            pathToFileURL(join(this.app.context.basedir, `package.json`)));
    }
    /**
     * Read `package.json` manifest from a module signifier
     */
    async readManifest(signifier) {
        return await this.getManifestPath(signifier).then(async (path) => {
            logger.scope(`module`).info(signifier, `manifest resolved to`, path);
            return await this.app.fs.read(path);
        });
    }
    /**
     * Cache location
     */
    get resolutionsPath() {
        return join(paths.storage, `bud.resolutions.yml`);
    }
    /**
     * Resolve a module path from its signifier
     */
    async resolve(signifier, context) {
        if (this.resolved?.[signifier]) {
            logger
                .scope(`module`)
                .info(`[cache hit]`, `resolved ${signifier} to ${this.resolved[signifier]}`);
            return this.resolved[signifier];
        }
        await resolve(signifier, this.makeContextURL())
            .then(path => {
            this.resolved[signifier] = normalize(fileURLToPath(path));
            logger
                .scope(`module`)
                .info(`[cache miss]`, `resolved ${signifier} to ${this.resolved[signifier]}`);
        })
            .catch(noop);
        if (this.resolved[signifier])
            return this.resolved[signifier];
        await resolve(signifier, this.makeContextURL(context))
            .then(path => {
            this.resolved[signifier] = normalize(fileURLToPath(path));
            logger
                .scope(`module`)
                .info(`[cache miss]`, `resolved ${signifier} to ${this.resolved[signifier]}`);
        })
            .catch(noop);
        if (this.resolved[signifier])
            return this.resolved[signifier];
        throw new ModuleError(`Could not resolve ${signifier}`);
    }
}
__decorate([
    bind
], Module.prototype, "after", null);
__decorate([
    bind
], Module.prototype, "bootstrap", null);
__decorate([
    bind
], Module.prototype, "compilerBefore", null);
__decorate([
    bind
], Module.prototype, "getDirectory", null);
__decorate([
    bind
], Module.prototype, "getManifestPath", null);
__decorate([
    bind
], Module.prototype, "import", null);
__decorate([
    bind
], Module.prototype, "makeContextURL", null);
__decorate([
    bind
], Module.prototype, "readManifest", null);
__decorate([
    bind
], Module.prototype, "resolve", null);
